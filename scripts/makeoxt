#!/usr/bin/python

import time, os, codecs, sys
try:
    import oxttools.xmltemplate as xtmpl
except ImportError:
    sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'lib')))
    import oxttools.xmltemplate as xtmpl
import oxttools.hunspell as hs
from argparse import ArgumentParser
from zipfile import ZipFile, ZipInfo, ZIP_DEFLATED
import lxml.etree as et

if sys.version_info[0] >= 3 :
    unicode = str

def zipadd(zipfile, data, fname) :
    zinfo = ZipInfo()
    zinfo.filename = fname
    tlocal = time.localtime()
    zinfo.date_time = (tlocal[0], tlocal[1]+1, tlocal[2]+1, tlocal[3], tlocal[4], tlocal[5])
    zinfo.compress_type = ZIP_DEFLATED
    zinfo.external_attr = 0664 << 16
    zipfile.writestr(zinfo, data)

def ziphunspell(ozip, hun, name) :
        zipadd(ozip, hun.getaff().encode('utf-8'), 'dictionaries/' + name + '.aff')
        zipadd(ozip, hun.getdic().encode('utf-8'), 'dictionaries/' + name + '.dic')

def zipnfcfile(ozip, fin, fout, affix=None) :
    dat = ""
    with open(fin) as fd :
        dat += u"\n".join([unicodedata.normalize('NFC', x) for x in fd.readlines()])
    if affix is not None :
        with oepn(affix) as fd:
            dat += u"\n".join([unicodedata.normalize('NFC', x) for x in fd.readlines()])
    zipadd(ozip, dat.replace("\uFEFF", ""), fout)

scripttypes = {
    'west' : 1,
    'asian' : 2,
    'ctl' : 3,
    'rtl' : 4,
    'none' : ""
}

parser = ArgumentParser()
parser.add_argument('langtag',help='language tag for this extension')
parser.add_argument('outfile',help='output oxt file')
parser.add_argument('-w','--word',default="",help="ASCII punctuation characters that are word forming")
parser.add_argument('-t','--type',default='west',help='script type [west, asian, ctl, rtl, none] Use none if libo already knows about the tag.')
parser.add_argument('-f','--font',action='append',help='Specifies font for semantic font e.g. -f UI_SANS="Times New Roman". May be repeated')
parser.add_argument('-l','--langname',help='Language name for UI strings')
parser.add_argument('-d','--dict',help='Wordlist dictionary. For hunspell dictionaries, specify the .aff file. Will try to infer what kind of xml')
parser.add_argument('-a','--affix',help='Merge the given affix file data into the generated .aff file')
parser.add_argument('-v','--version',default='0.1',help='OXT version number')
parser.add_argument('--dicttype',help='Specifies dictionary type [hunspell, pt, ptstrict, text]')
parser.add_argument('--publisher',help='Name of publisher')
parser.add_argument('--puburl',default='',help='URL of publisher')
args = parser.parse_args()

resdir = os.path.join(os.path.dirname(xtmpl.__file__), 'data')
scripttype = scripttypes.get(args.type.lower(), 1)

ozip = ZipFile(args.outfile, "w")
t = xtmpl.Templater()

fontmap = {}
if args.font is not None :
    for f in args.font :
        (id, name) = f.split('=')
        fontmap[id] = name
    t.define('fonttypes', " ".join(sorted(fontmap.keys())))
else :
    t.define('fonttypes', '')
if args.langname is None : args.langname = args.langtag


def fn_fonts(context, name) :
    return fontmap[name]

t.define('langtag', args.langtag)
t.define('resdir', resdir)
t.define('scripttype', str(scripttype))
t.define('language', args.langname)
t.define('version', args.version)
if args.publisher is not None :
    t.define('publisher', args.publisher)
    t.define('puburl', args.puburl)
else :
    t.define('publisher', '')
t.addfn(None, 'fonts', fn_fonts)
t.parse(os.path.join(resdir, 'dictxcu.xml'))
t.process()
zipadd(ozip, unicode(t).encode('utf-8'), 'dictionaries.xcu')

t.parse(os.path.join(resdir, 'oxtdescription.xml'))
t.process()
zipadd(ozip, unicode(t).encode('utf-8'), 'description.xml')

license="""LICENSES:
Spell checker: MIT

https://opensource.org/licenses/MIT
"""
zipadd(ozip, license.encode('utf-8'), 'LICENSES-en.txt')

manifest="""<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE manifest:manifest PUBLIC "-//OpenOffice.org//DTD Manifest 1.0//EN" "Manifest.dtd">
<manifest:manifest xmlns:manifest="http://openoffice.org/2001/manifest">
    <manifest:file-entry manifest:media-type="application/vnd.sun.star.configuration-data" manifest:full-path="dictionaries.xcu"/>
</manifest:manifest>
"""
zipadd(ozip, manifest.encode('utf-8'), 'META-INF/manifest.xml')

if args.dict :
    if not args.dicttype :
        if args.dict.endswith('.aff') :
            args.dicttype = 'hunspell'
        elif args.dict.endswith('.xml') :
            # should dig into xml, but for now we only know about one type
            args.dicttype = 'pt'
        elif args.dict.endswith('.txt') :
            args.dicttype = 'text'
    if args.dicttype == 'hunspell' :
        zipnfcfile(ozip, args.dict, 'dictionaries/' + args.langtag + '.aff', args.affix)
        d = args.dict.replace('.aff', '.dic')
        zipnfcfile(ozip, d, 'dictionaries/' + args.langtag + '.dic', None)
    elif args.dicttype == 'pt' or args.dicttype == 'ptstrict' :
        doc = et.parse(args.dict)
        hun = hs.Hunspell(args.langtag, puncs=args.word)
        for e in doc.findall('//item') :
            if args.dicttype == 'ptstrict' and e.attrib['spelling'] != 'Correct' : continue
            hun.addword(e.attrib['word'])
        if args.affix is not None :
            hun.mergeaffix(args.affix)
        ziphunspell(ozip, hun, args.langtag)
    elif args.dicttype == 'text' :
        hun = hs.Hunspell(args.langtag, puncs=args.word)
        with codecs.open(args.dict, encoding='utf-8') as infile :
            for l in infile.readlines() :
                hun.addword(l.replace("\uFEFF", "").strip())
        if args.affix is not None :
            hun.mergeaffix(args.affix)
        ziphunspell(ozip, hun, args.langtag)

ozip.close()
